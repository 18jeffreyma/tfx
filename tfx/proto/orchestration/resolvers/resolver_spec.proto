// Copyright 2020 Google LLC. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package tfx.orchestration;


// Range selection spec for a certain property.
message RangeSelection {
  // Property to apply selection to.
  // - For custom artifact store, this is the property name defined in type.
  // - For TFX artifact sotre, this is property name in proto option of
  //   TFXArtifactStore.
  string property_name = 1;
  oneof type {
    // Only PropertyValues can be consumed by data flow.
    PropertyValues property_values = 2;
    RangeSelectionConfig range_selection_config = 3;
  }
}

// The resolver spec definition for text properties.
message PropertyValues {
  // Property values.
  repeated string values = 2;

  reserved 1;
}

// The resolver spec definition for all kinds of numerric ranges.
// Next ID: 5
message RangeSelectionConfig {
  // Describes a static window within the specified numbers
  // [start_number, end_number]. If not all numbers in the range are
  // available, processing may continue on a partial range.
  // Note that both numbers should be specified for StaticRange.
  message StaticRange {
    int32 start_number = 1;
    // End is inclusive
    int32 end_number = 2;
    // Minimum number of desired artifacts in the range.  Processing will
    // wait if fewer than the specified number of artifacts are available in the
    // current range.
    // If min_items_in_range is not set or set to an non-positive value,
    // it defaults to end_number - start_number + 1.
    // If allow_empty_result is true, this field will be ignored.
    int32 min_items_in_range = 3;
  }

  // Describes a rolling range:
  // [most_recent_number - skip_num_recents - range_length + 1,
  //  most_recent_number - skip_num_recents].
  // For example, say you want the range to include only the latest number,
  // the appropriate RollingRange would simply be:
  // RollingRange <
  //   range_length = 1
  // >
  // The range is clipped based on available data.
  // Note that range_length is required in RollingRange, while others are
  // optional.
  message RollingRange {
    // Starting number before which no number will be considered.
    int32 start_number = 1;
    // Length of the range, when the number of resolved artifacts is less than
    // to range_length, iteration won't be triggered unless min_items_in_range
    // is specify to a smaller number than range_length.
    int32 range_length = 2;
    // Number of most recent numbers to skip from source component. This
    // means you should set this field separately for, say, the ExampleGen and
    // Trainer components as ExampleGen interprets this for span property as
    // "number of most recent spans to skip from all available data" while the
    // Trainer reads this as
    // "number of most recent spans to skip from those that have been generated
    // by ExampleGen". Thus, to skip the last 7 days' data and train on 30 days,
    // set range_length: 30 in both ExampleGen and Trainer, while setting
    // range_length: 7 in ExampleGen and leaving it unset in Trainer
    // so it defaults to zero. To generate 30 days' data, again ignoring the
    // last 7 days, but training on 23 days, skipping the past 14 days, set
    // range_length: 30 and skip_num_recents: 7 in ExampleGen, while in Trainer
    // set range_length: 23 and skip_num_recents: 7.
    int32 skip_num_recents = 3;
    // Minimum number of desired artifacts in the range. Processing will
    // wait if fewer than the specified number of artifacts are available in the
    // current range.
    // If min_items_in_range is not set or set to an non-positive value,
    // it defaults to range_length.
    // If allow_empty_result is true, this field will be ignored.
    int32 min_items_in_range = 4;
  }

  // Describes a sequentially rolling range:
  // [latest_processed_number + 1, latest_processed_number + range_length].
  // Configures processing a sequential window of "range_length". As opposed
  // to RollingRange, SequentialRollingRange will always operate on the oldest
  // span window of **consecutive** numbers that is not processed yet (note
  // that there must not be gaps in numbers unless these gaps are explicitly
  // configured as exclude_numbers). E.g. with configuration:
  // sequential_rolling_range: {
  //   range_length: 5
  //   start_number: 10
  // }
  // the component will start with range [10, 14] and move forward one number at
  // a time. If there are gaps in the range, processing will pause until the
  // gaps are filled.
  // start_number and skip_num_recents are 0 by default. It is necessary to
  // specify start_number if the number don't start from 0 index.
  // range_length should be set to a non-zero value.
  message SequentialRollingRange {
    // Starting number to start the sequential rolling from.
    int32 start_number = 1;
    // Length of the range, when the number of resolved artifacts is less than
    // to range_length, iteration won't be triggered.
    int32 range_length = 2;
    // Number of most recent numbers to skip.
    int32 skip_num_recents = 3;
  }

  // Either should be specified.
  oneof range {
    StaticRange static_range = 1;
    RollingRange rolling_range = 2;
    SequentialRollingRange sequential_rolling_range = 4;
  }

  // Numbers to exclude always from the range.
  // Note that exclude_numbers are counted towards min_items_in_range.
  // TODO(muyangy): As discussed offline we should move exclude_numbers into
  // every range config as part of the simplify ConfigV2 effort.
  repeated int32 exclude_numbers = 3;
}
